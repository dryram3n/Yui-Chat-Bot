/**
 * Markdown Formatter for Yui Chat Bot
 * Converts markdown-style text to HTML for message display
 */

// Main function to convert markdown text to HTML
function formatMarkdown(text) {
  if (!text) return '';
  
  let formattedText = text;
  
  // Escape HTML to prevent XSS - REMOVED from global application at the start
  // formattedText = escapeHtml(formattedText); 
  
  // Format bold: **text** or __text__
  formattedText = formattedText.replace(/(\*\*|__)(.+?)\1/g, (match, delimiter, content) => {
    return `<strong>${escapeHtml(content)}</strong>`;
  });
  
  // Format italic: *text* or _text_
  // Ensure this doesn't conflict heavily with bold if they are processed separately.
  // This rule should ideally be applied after bold or use negative lookaheads/behinds
  // if complex nesting is required. For simple cases, this is okay.
  formattedText = formattedText.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)|(?<!_)_(?!_)(.+?)(?<!_)_(?!_)/g, (match, content1, content2) => {
    const content = content1 || content2;
    return `<em>${escapeHtml(content)}</em>`;
  });
  
  // Format strikethrough: ~~text~~
  formattedText = formattedText.replace(/~~(.+?)~~/g, (match, content) => {
    return `<del>${escapeHtml(content)}</del>`;
  });
  
  // Format code blocks: ```language\ncode\n```
  formattedText = formattedText.replace(/```([a-z]*)\n([\s\S]*?)\n```/g, (match, language, code) => {
    // Content of code blocks is typically escaped by syntax highlighters if used,
    // but escaping here ensures safety if no highlighter is present.
    return `<pre class="code-block${language ? ' language-' + language : ''}"><code>${escapeHtml(code)}</code></pre>`;
  });
  
  // Format inline code: `code`
  formattedText = formattedText.replace(/`([^`]+)`/g, (match, code) => {
    return `<code>${escapeHtml(code)}</code>`;
  });
  
  // Format unordered lists: - item or * item
  // formatLists needs to be adjusted or called carefully if initial escape is removed.
  // For now, assuming formatLists will handle content that might need escaping.
  // The content within <li> generated by formatLists should be escaped.
  formattedText = formatLists(formattedText, true); // Pass a flag to escape content in lists
  
  // Format links: [text](url)
  formattedText = formattedText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, url) => {
    // URLs themselves should be carefully handled. escapeHtml is a basic measure.
    // Attributes like href have specific encoding needs for robustness.
    return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(linkText)}</a>`;
  });
  
  // Replace line breaks with <br> AFTER list processing
  // This regex ensures that <br> is not inserted inside <pre> or after <li> that will be handled by list styling.
  // A more robust way would be to split by \n and process blocks.
  // For now, this is a common simple approach.
  // Ensure this doesn't break <pre> tags. Code blocks handle their newlines internally.
  // Only replace newlines that are not part of a list item's content that formatLists handles.
  // This step is tricky. If formatLists returns text with \n that are meant to be <br>, this is okay.
  // If formatLists structures everything, then this might only apply to non-list paragraph breaks.
  
  // Apply line breaks to lines not already part of a list structure or pre block
  const lines = formattedText.split('\n');
  const processedLines = [];
  let inPreBlock = false;
  for (const line of lines) {
    if (line.includes('<pre')) inPreBlock = true;
    if (inPreBlock) {
        processedLines.push(line);
    } else {
        // Avoid adding <br> to empty lines that might be between list items from formatLists
        // or if the line is already an HTML block element.
        // This is a simplification; proper block-level element detection is complex.
        if (line.trim() === '' || line.match(/^\s*<(ul|ol|li|div|p|h[1-6]|blockquote|pre)/i)) {
            processedLines.push(line);
        } else {
            processedLines.push(line + '<br>');
        }
    }
    if (line.includes('</pre>')) inPreBlock = false;
  }
  // Remove trailing <br> if the last line was processed to have one and was the end.
  formattedText = processedLines.join('\n').replace(/<br>\s*$/, '');


  return formattedText;
}

// Format lists (both ordered and unordered)
function formatLists(text, shouldEscapeContent = false) {
  const lines = text.split('\n');
  let inList = false;
  let listType = ''; // 'ul' or 'ol'
  let formattedLines = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    const unorderedMatch = line.match(/^\s*([-*])\s+(.+)$/);
    const orderedMatch = line.match(/^\s*(\d+)\.\s+(.+)$/);
    
    let currentContent = '';

    if (unorderedMatch) {
      if (!inList || listType !== 'ul') {
        if (inList) formattedLines.push(`</${listType}>`); // Close previous list
        formattedLines.push('<ul>');
        inList = true;
        listType = 'ul';
      }
      currentContent = unorderedMatch[2];
      formattedLines.push(`<li>${shouldEscapeContent ? escapeHtml(currentContent) : currentContent}</li>`);
    } else if (orderedMatch) {
      if (!inList || listType !== 'ol') {
        if (inList) formattedLines.push(`</${listType}>`); // Close previous list
        formattedLines.push('<ol>');
        inList = true;
        listType = 'ol';
      }
      currentContent = orderedMatch[2];
      formattedLines.push(`<li>${shouldEscapeContent ? escapeHtml(currentContent) : currentContent}</li>`);
    } else {
      if (inList) {
        formattedLines.push(`</${listType}>`);
        inList = false;
        listType = '';
      }
      formattedLines.push(line); // Pass through non-list lines
    }
  }
  
  if (inList) {
    formattedLines.push(`</${listType}>`); // Close any open list at the end
  }
  
  return formattedLines.join('\n'); // Keep \n for further processing or CSS handling
}

// Escape HTML to prevent XSS attacks
function escapeHtml(text) {
  const htmlEntities = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };
  
  return text.replace(/[&<>"']/g, char => htmlEntities[char]);
}

// Export the formatter function
window.markdownFormatter = {
  format: formatMarkdown
};